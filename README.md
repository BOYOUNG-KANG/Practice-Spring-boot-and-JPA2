# '실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화' 강의에 대해 공부한 자료입니다.

 --------

## 이해한 내용 정리
### ToOne 관계
- ToOne 관계에서 발생하는 n + 1의 경우, fetch join 사용하여 충분히 해결 가능하다.
- 따라서 ToOne 관계는 fetch join + dto 변환 + json 객체 변환 방식을 사용하는 것을 추천 (성능은 좀 떨어질 수 있으나 높은 재사용성)
- jpa에서 dto로 바로 조회하는 방식을 사용할 수도 있는데, 성능은 올라가는 대신 재사용성이 떨어져서 두 방법 사이의 trade off가 있다.

### ToMany 관계 (컬렉션)
- ToMany 관계에서는 이보다 더 복잡한데, fetch join을 써도 데이터 뻥튀기(중복 조회)가 발생하므로 페이징이 불가능해지기 때문이다.
  - 1의 시점으로 페이징하고 싶으나 n의 시점으로 페이징이 되기 때문에 개발자 의도대로 페이징이 불가
- 따라서 ToMany 관계가 있을 경우, ToOne 관계까지는 fetch join을 사용하고 ToMany 부분인데 페이징이 필요 없는 경우 fetch join + distinct를 사용하고, 페이징이 필요한 ToMany 부분은 지연로딩 + `hibernate.default_batch_size`를 사용하는 방식 권장
### OSIV
- `spring.jpa.open-in-view`
- 트래픽 높은 서비스에서 무조건 꺼야 하는 아이
- 영속성 컨텍스트(with 데이터베이스 커넥션)을 응답 시점까지 살아있도록 하는 아이
  - 지연로딩을 가능케 하나 커넥션을 매마르게해서 서비스 장애를 불러일으킬 수 있다.
- 트래픽 높은 서비스에서 osiv 무조건 끄고 controller나 view에서 지연로딩이 필요한 부분을 트랜잭션으로 옮겨놓는 방식으로 작업하는 것이 좋다.
  - 커멘드와 쿼리를 분리하라
    - 주요 비즈니스 계층과 쿼리 계층을 분리
    - 핵심 비즈니스 계층은 성능이 크게 중요하지 않는 경우가 많으므로 osiv ON
    - 화면이나 api 맞춘 서비스(조회 등의 쿼리 계층)는 성능이 중요해지는 경우가 많으므로 osiv OFF
### 스프링 데이터 JPA
- jpaRepository를 사용하여 repository에 넣을 기본 기능을 자동으로 사용 가능
### queryDSL
- 동적 쿼리는 물론 정적 쿼리까지 간편하게 쿼리를 짤 수 있는 매우 필요한 아이

## 깨달은 내용
데이터를 가져오는 다양한 방식에 대해 알아보았다. 어떤 방식은 확실히 잘못된 방식이 있는 반면, 어떤 방식들은 장단점이 있어서 상황에 따라 선택해야하는 경우가 생겨 많은 생각을 하게 만들었다. queryDsl을 사용하면 보다 처리가 가능하다고 해서 다음엔 queryDsl을 공부할 예정이다.



